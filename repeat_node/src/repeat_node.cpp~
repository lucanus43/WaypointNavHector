/* repeat_node.cpp 
   
Desc:	Performs the repeat node for visual teach and repeat implementation.
		Note: BG. - Background tasks
		

Author: Jeffrey Devaraj
Date: 161125 

*/

// ------------------------- DECLARATIONS ------------------------------ //

// C/C++ Includes
#include <iostream>
#include <cstdio>
#include <cmath>
#include <string>
#include <sstream>
#include <vector>
#include <fstream>
// ROS Includes
#include <ros/ros.h>
#include <nav_msgs/Odometry.h>
#include <image_transport/image_transport.h>
#include "actionlib/client/simple_action_client.h"
// OpenCV Includes
#include <opencv2/highgui/highgui.hpp>
#include <cv_bridge/cv_bridge.h>
#include <std_srvs/Empty.h>
// Hector includes
#include "hector_uav_msgs/TakeoffAction.h"
#include "hector_uav_msgs/LandingAction.h"
#include "hector_uav_msgs/PoseAction.h"
// PCL includes
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/PCLPointCloud2.h>
#include <pcl/conversions.h>
#include <pcl_ros/transforms.h>
// TF includes
#include <tf/transform_broadcaster.h>
#include <tf/transform_listener.h> // for tf::getPrefixParam()
#include <tf/transform_datatypes.h>
#include "tf/LinearMath/Transform.h"	// To convert between geometry_msgs and TF libraries
// JDev Files
#include "cvUtility.h"
#include "map_packaging.h"


using namespace cv;

// ---------------------- GLOBAL VARIABLES -----------------------------//
// Main variables
	Mat SCLL_cmd;
	Mat SBLL_cmd = Mat::zeros(3,1,CV_64F);
	Mat TCL_cmd;
	Mat TBL_cmd = Mat::zeros(3,3,CV_64F);
	Mat QCL_cmd;
	double wp_radius = 0.01;
	vector<geometry_msgs::Pose> waypointsCL;
	int wp_counter = 0;
	bool next_map = false;
	Mat QCB = Mat::zeros(4,1,CV_64F);
	Mat TCB = Mat::zeros(3,3,CV_64F);
	Mat SCBB = Mat::zeros(3,1,CV_64F);
	Mat QBL_cmd = Mat::zeros(4,1,CV_64F);
	geometry_msgs::PoseStamped gmBL_cmd;

// Odometry Variables
	Mat TRLhat = Mat::zeros(3,3,CV_64F);
	Mat TCRhat = Mat::zeros(3,3,CV_64F);
	Mat SRLLhat = Mat::zeros(3,1,CV_64F);
	Mat TCLhat= Mat::zeros(3,3,CV_64F);			// Needs initialising
	Mat SCLLhat = Mat::zeros(3,1,CV_64F);		// Needs initialising
	Mat TRL = Mat::zeros(3,3,CV_64F);
	Mat TCL = Mat::zeros(3,3,CV_64F);
	Mat SRLL = Mat::zeros(3,1,CV_64F);
	Mat SCLL = Mat::zeros(3,1,CV_64F);
	
// Teach node variables
	Mat TOLhat = Mat::zeros(3,3,CV_64F);
	Mat SOLLhat = Mat::zeros(3,1,CV_64F);

// Point cloud registration variables
	Mat TROhat = Mat::zeros(3,3,CV_64F);
	Mat SROLhat = Mat::zeros(3,1,CV_64F);


// Takeoff client (SimpleActionClient from actionlib)
typedef actionlib::SimpleActionClient<hector_uav_msgs::TakeoffAction> TakeoffClient;
typedef actionlib::SimpleActionClient<hector_uav_msgs::PoseAction> PoseActionClient;

// -------------------------------------------------------------
/*
cloudCallBack - Callback function for pointcloud subscriber
				Derived from: http://answers.ros.org/question/136916/conversion-from-sensor_msgspointcloud2-to-pclpointcloudt/

Author: JDev 161125
	
*/
// -------------------------------------------------------------
void cloudCallBack(const boost::shared_ptr<const sensor_msgs::PointCloud2>& input) {
	// Local Variables
	pcl::PCLPointCloud2 pcl_pc2;
	pcl::PointCloud<pcl::PointXYZ>::Ptr temp_cloud(new pcl::PointCloud<pcl::PointXYZ>); // temp_cloud is in PointXYZ form
	
	// TODO: Do this only once per submap (SRO and TRO should be constant for each cloud).
	// Process
	pcl_conversions::toPCL(*input,pcl_pc2);
    pcl::fromPCLPointCloud2(pcl_pc2,*temp_cloud);
    // Perform ICP on temp_cloud
    // ..
    
    // Obtain error displacement and transformation matrix
    // SRO = error displacement, TRO = error transform
    // TODO: Work out what coordinates SRO is in.
    
    //
    
}



// -------------------------------------------------------------
/*
odomCallBack- 	Called when odometry is received.
				R: Repeat pass odometry frame
		

Author: JDev 161125
	
*/
// -------------------------------------------------------------

void odomCallBack(const nav_msgs::Odometry::ConstPtr& odomMsg){
	// Local variables
	Mat SCRChat = Mat::zeros(3,1,CV_64F);
	Mat QCRhat = Mat::zeros(3,1,CV_64F);
	
	// Process
	// Obtain SCRC
	SCRChat.at<double>(0) = (odomMsg->pose.pose.position.x);
	SCRChat.at<double>(1) = (odomMsg->pose.pose.position.y);
	SCRChat.at<double>(2) = (odomMsg->pose.pose.position.z);
	
	// Get QCR from quaternion in odomMsg
	QCRhat.push_back(odomMsg->pose.pose.orientation.x); 
	QCRhat.push_back(odomMsg->pose.pose.orientation.y); 
	QCRhat.push_back(odomMsg->pose.pose.orientation.z); 
	QCRhat.push_back(odomMsg->pose.pose.orientation.w); 
	
	// Convert QCR to TCR
	TCRhat = quat2dcm(QCRhat);
	
	// Compute SRLLhat and TRLhat - needs to only be done once per submap - constant.
	
	// VO alone approach. This will need TCLhat and SCLLhat to be initialised somehow.
	// e.g. TCLhat = TCB*TBLhat with TBLhat from IMU/magnetometer, SCLLhat = SCBL + SBLLhat with SBLLhat from GPS.
	// TRLhat = TCRhat.t()*TCLhat;	
	// SRLLhat = -TRLhat*SCRChat + SCLLhat;
	
	// VO + ICP approach:
	TRLhat = TROhat*TOLhat;			// TODO: Get TOLhat embedded into posefiles, get TROhat from ICP
	SRLLhat = SROLhat + SOLLhat; 	// TODO: Get SROL from ICP (SOLLhat from posefile)
	
	// 'Truth' SRLL and TRL
	TRL = TCRhat.t()*TCL;						// Need TCL
	SRLL = -TRL*SCRChat + SCLL;				// Need SCLL
	
	// Update TCLhat and SCLLhat
	TCLhat = TCRhat*TRLhat;
	SCLLhat = TCLhat.t()*SCRChat + SRLLhat;
	
	ROS_INFO("Finished odomCallBack");
}


// -------------------------------------------------------------
/*
positionCallBack- 	Called when SBLL/TBL is received (listening for TBL - truth)
					Waypoint navigation is performed here.
					
					TODO: Listen for SCLLhat instead -> publish SCLLhat to TF

Author: JDev 161125
	
*/
// -------------------------------------------------------------
void positionCallBack( const geometry_msgs::PoseStamped::ConstPtr& gmBL ) {
	// Local variables
	Mat QCLhat;
	geometry_msgs::Pose gmCL;
	Mat SBLL = Mat::zeros(3,1,CV_64F);
	
	SBLL.at<double>(0) = gmBL->pose.position.x;
	SBLL.at<double>(1) = gmBL->pose.position.y;
	SBLL.at<double>(2) = gmBL->pose.position.z;
	// Output message to user
	ROS_INFO("SBLLhat: [%f,%f,%f]", SBLL.at<double>(0), SBLL.at<double>(1), SBLL.at<double>(2));
	ROS_INFO("SBLL_cmd: [%f,%f,%f]", SBLL_cmd.at<double>(0), SBLL_cmd.at<double>(1), SBLL_cmd.at<double>(2));

	
	// Force SCLLhat to converge to SCLL_cmd and TCLhat to converge to TCL_cmd
	QCLhat = dcm2quat(TCLhat);
	
	if( fabs( SCLLhat.at<double>(0) -  SCLL_cmd.at<double>(0) ) < wp_radius && fabs( QCLhat.at<double>(0) -  QCL_cmd.at<double>(0) ) < wp_radius) {
		if( fabs( SCLLhat.at<double>(1) - SCLL_cmd.at<double>(1))  < wp_radius && fabs( QCLhat.at<double>(1) -  QCL_cmd.at<double>(1) ) < wp_radius) {
			if( fabs( SCLLhat.at<double>(2) - SCLL_cmd.at<double>(2) )  < wp_radius && fabs( QCLhat.at<double>(2) -  QCL_cmd.at<double>(2) ) < wp_radius) {
				//If there are more waypoints
				wp_counter++;	//Move to the next waypoint
				if( wp_counter < waypointsCL.size() ) {
					SCLL_cmd.at<double>(0) = waypointsCL.at(wp_counter).position.x;
					SCLL_cmd.at<double>(1) = waypointsCL.at(wp_counter).position.y;
					SCLL_cmd.at<double>(2) = waypointsCL.at(wp_counter).position.z;
					QCL_cmd.at<double>(0) = waypointsCL.at(wp_counter).orientation.x;
					QCL_cmd.at<double>(1) = waypointsCL.at(wp_counter).orientation.y;
					QCL_cmd.at<double>(2) = waypointsCL.at(wp_counter).orientation.z;
					QCL_cmd.at<double>(3) = waypointsCL.at(wp_counter).orientation.w;
					// Convert SCLL_cmd to SBLL_cmd (SBLL = SBCL + SCLL)
					SBLL_cmd = TCLhat.t()*TCB*SCBB + SCLL_cmd;
					TBL_cmd = TCB.t()*quat2dcm(QCL_cmd);
					QBL_cmd = dcm2quat(TBL_cmd);
					// Export commanded pose as gmBL_cmd
					gmBL_cmd.pose.position.x = SBLL_cmd.at<double>(0);
					gmBL_cmd.pose.position.y = SBLL_cmd.at<double>(1);
					gmBL_cmd.pose.position.z = SBLL_cmd.at<double>(2);
					gmBL_cmd.pose.orientation.x = QBL_cmd.at<double>(0);
					gmBL_cmd.pose.orientation.y = QBL_cmd.at<double>(1);
					gmBL_cmd.pose.orientation.z = QBL_cmd.at<double>(2);
					gmBL_cmd.pose.orientation.w = QBL_cmd.at<double>(3);
					
				} else {
					next_map = true;
					ROS_INFO( "Finished the waypoint path!" );
				}	
			}
		}
	}
}

// -------------------------------------------------------------
/*
generateWaypoints -	Generates waypoints from the given poses.txt file
					Called every time a submap is loaded.
					
					NOTE: Uses globals SCLL_cmd and QCL_cmd. This should not affect
					the variable used in the rest of the script since this is only
					called at the beginning and the values will be changed in the first
					positionCallBack.
					TODO: Check if this is true.

Author: JDev 161125
	
*/
// -------------------------------------------------------------
void generateWaypoints(string poseFileName){
	// Local variables
	fstream poseFile;
	vector<Mat> vecSCOL;
	vector<Mat> vecQCL;
	geometry_msgs::Pose temp_wp;

	
	// Read in waypoints from poseFile along with SOLLhat
	poseFile.open(poseFileName.c_str());
	if(poseFile.fail()){
		ROS_ERROR_STREAM("Error: File stream " << poseFileName << " failed to open (check spelling)");
		ros::shutdown(); 
	}
	
	// Generate waypoints as SCLL_cmd and QCL_cmd using SCOLhat and SOLLhat and QCL from pose file
		// SCLL_cmd = SCOLhat + SOLLhat
		// QCL_cmd = posefile.QCL
	extractPosesFromFile(poseFile, SOLLhat, vecSCOL, vecQCL);
	
	// Subsample pose file
	// .. TODO
	
	// Create waypoints
	for (int i = 0; i < vecSCOL.size(); i++){
		// Commanded displacement vector rel. Local Level frame
		SCLL_cmd = vecSCOL[i] + SOLLhat;
		QCL_cmd = vecQCL[i];
		// Geometry message
		temp_wp.position.x = SCLL_cmd.at<double>(0);
		temp_wp.position.y = SCLL_cmd.at<double>(1);
		temp_wp.position.z = SCLL_cmd.at<double>(2);
		temp_wp.orientation.x = QCL_cmd.at<double>(0);
		temp_wp.orientation.y = QCL_cmd.at<double>(1);
		temp_wp.orientation.z = QCL_cmd.at<double>(2);
		temp_wp.orientation.w = QCL_cmd.at<double>(3);
		// Waypoints (pose of C wrt. L)
		waypointsCL.push_back(temp_wp);
	}
}

// -------------------------------------------------------------
/*
loadSubmapPCD -	Loads a Pointcloud into memory

Author: JDev 161125
	
*/
// -------------------------------------------------------------
void loadSubmapPCD(string PCDFileName){
	// Local variables
	// ..
	
	// Load submap into a pointxyz variable
	// ..
	
}



// -------------------------------------------------------------
/*
main -	Main execution loop

Author: JDev 161125
	
*/
// -------------------------------------------------------------
int main(int argc, char **argv){
	// Initialise ROS
	ros::init(argc, argv, "repeat_node");
	// Create node handle
	ros::NodeHandle nh;

	// Local  ROS elements (subscribers, listeners, publishers, etc.)
	ros::Subscriber odomSub;	// Visual Odometry (VO) subscriber
	//ros::Subscriber cloudSub;	// Point cloud subscriber
	ros::Subscriber cmdPoseSub;
	PoseActionClient PAC(nh, "action/pose");	// Pose action client
	TakeoffClient TAC(nh, "action/takeoff");	// Takeoff action client
	
	// Local variables
	hector_uav_msgs::PoseGoal poseGoal;		// PoseGoal object for simpleactionclient PoseActionClient
	hector_uav_msgs::TakeoffGoal takeoffgoal;		// Goal (empty message) for TakeoffClient
	
	// Initialisation
	// Subscribe to odom topic
	odomSub = nh.subscribe("/rtabmap/odom", 1, odomCallBack);
	// Subscribe to cloud_map topic
	//cloudSub = nh.subscribe("rtabmap/cloud_map", 1000, cloudCallBack);
	// Subscribe to positionCallBack
	cmdPoseSub = nh.subscribe("/command/pose", 1000, positionCallBack);
	
	// Start on submap_0 -> pose_0.txt, submap_0.pcd.
	// TODO: Make the map selection based on SCLLhat and SOLL and direction of travel (alternatively,
	// scan all maps and load all SOLL values and compare SCLLhat)
	generateWaypoints("pose_0.txt");
	loadSubmapPCD("submap_0.pcd");
	
	// Set first waypoint goal
	// TODO: use geometry_msgs instead of cv::Mat for commanded pose?
	// TODO: Make a function cv::Mat <- gmBA to save space
	SCLL_cmd.at<double>(0) = waypointsCL.at(wp_counter).position.x;
	SCLL_cmd.at<double>(1) = waypointsCL.at(wp_counter).position.y;
	SCLL_cmd.at<double>(2) = waypointsCL.at(wp_counter).position.z;
	QCL_cmd.at<double>(0) = waypointsCL.at(wp_counter).orientation.x;
	QCL_cmd.at<double>(1) = waypointsCL.at(wp_counter).orientation.y;
	QCL_cmd.at<double>(2) = waypointsCL.at(wp_counter).orientation.z;
	QCL_cmd.at<double>(3) = waypointsCL.at(wp_counter).orientation.w;
	// Convert SCLL_cmd to SBLL_cmd (SBLL = SBCL + SCLL)
	SBLL_cmd = TCLhat.t()*TCB*SCBB + SCLL_cmd;
	TBL_cmd = TCB.t()*quat2dcm(QCL_cmd);
	QBL_cmd = dcm2quat(TBL_cmd);
	ROS_INFO_STREAM("SBLL_cmd: " << SBLL_cmd);
	// Export commanded pose as gmBL_cmd
	gmBL_cmd.pose.position.x = -1.0;
	gmBL_cmd.pose.position.y = -1.0;
	gmBL_cmd.pose.position.z = 5.0;
	gmBL_cmd.pose.orientation.x = QBL_cmd.at<double>(0);
	gmBL_cmd.pose.orientation.y = QBL_cmd.at<double>(1);
	gmBL_cmd.pose.orientation.z = QBL_cmd.at<double>(2);
	gmBL_cmd.pose.orientation.w = QBL_cmd.at<double>(3);
	
	// Set TCB/SCBB
	QCB.at<double>(1) = 0.707; QCB.at<double>(3) = 0.707;
	TCB = quat2dcm(QCB);
	// Set SCBB
	SCBB.at<double>(0) = 0.1;
	SCBB.at<double>(2) = -0.03;
	
	// Initialise the PoseActionClient
	PAC.waitForServer();
	ROS_INFO("Pose client initialised.");
	
	// Initialise the TakeoffClient
	TAC.waitForServer();
	ROS_INFO("Takeoff client initialised.");
	// Send take-off goal to TAC -> taking off.
	TAC.sendGoal(takeoffgoal);
	
	// Loop
	ros::Rate rate(10.0);
	while(nh.ok()){
		// Waypoint navigation using SCLLhat and SCLL_cmd, TCLhat and TCL_cmd (convert to B frame?)
		//Update our message so the receiving node knows it is recent
		gmBL_cmd.header.stamp = ros::Time::now();
		gmBL_cmd.header.seq++;
		gmBL_cmd.header.frame_id = "world";

		// Send current goal to pose
		poseGoal.target_pose = gmBL_cmd; 
		PAC.sendGoal(poseGoal);
		// if waypoints complete
			// if next submap exists, move to next submap. (set new waypoints/goal)
			// else exit.
		// endif
		
		// Perform spin
		ros::spinOnce();
		rate.sleep();
	}
	
}






















